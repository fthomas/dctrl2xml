#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# dctrl2xml - Debian control data to XML converter
# Copyright Â© 2005-2007 by Frank S. Thomas <fst@debian.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import re
import optparse
import types
import time

import bz2
import gzip
import zipfile

from debian_bundle import deb822
from elementtree.ElementTree import Element, SubElement, dump

__author__ = 'Frank S. Thomas'
__version__ = '0.9'


class DebianControlParser:

    def __init__(self):
        self.contacts = ['maintainer', 'changed-by', 'uploaders']
        self.relations = ['depends', 'pre-depends', 'suggests', 'recommends',
            'conflicts', 'provides', 'replaces', 'enhances', 'build-depends',
            'build-depends-indep', 'build-conflicts', 'build-conflicts-indep',
            'breaks']


    def parse_package_string(self, pkg_str):
        self.pkg = deb822.Deb822(pkg_str)

        pkg = {}
        for orig_field in self.pkg:
            field = orig_field.lower()

            if field in self.contacts:
                pkg[field] = self.parse_contacts(self.pkg[field])

            elif field in self.relations:
                pkg[field] = self.parse_relations(self.pkg[field])

            elif field == 'package':
                pkg['name'] = self.pkg[field]

            elif field == 'date':
                pkg[field] = self.pkg[field]
                pkg['date_iso8601'] = self.parse_date(self.pkg[field])

            elif field == 'files':
                pkg[field] = self.parse_filelist(self.pkg[field])

            elif field == 'description':
                m = re.search(r'\n', self.pkg[field])
                if m:
                    synopsis = self.pkg[field][:m.start()].strip()
                    extended = self.pkg[field][m.end():]

                    if len(synopsis) == 0:
                        pkg[field] = extended
                    else:
                        pkg[field] = synopsis
                        pkg['long-description'] = extended
                else:
                    pkg[field] = self.pkg[field]

            elif field == 'tag':
                pkg[field] = self.parse_debtags(self.pkg[field])

            else:
                pkg[field] = self.pkg[field]

        self.pkg = pkg
        return self.pkg


    def parse_contacts(self, contacts_str):
        contacts = []

        split_re = r'\s*((.+?)\s+?<(.+?)>,?|(.+?)\s+?\((.+?)\),?)'
        s = re.split(split_re, contacts_str)

        for contact in [s[x:x+6] for x in range(0, len(s), 6)]:
            if len(contact) != 6:
                continue
            elif contact[2] and contact[3]:
                c = {'name': contact[2], 'email': contact[3]}
            elif contact[5] and contact[4]:
                c = {'name': contact[5], 'email': contact[4]}

            contacts.append({'contact': c})

        return contacts


    def parse_filelist(self, files_str):
        files = {}
        files_re = {
            'deb': '.*\.deb',
            'dsc': '.*\.dsc',
            'diff': '.*\.diff\.gz',
            'tarball': '.*\.tar\.(gz|bz2|lzma)'
        }

        for line in re.finditer(r' ([\da-f]{32}.*)', files_str):
            attrs = line.group(1).split()
            for file_type, file_re in files_re.iteritems():
                if re.search(file_re, attrs[-1]):
                    files[file_type] = {}
                    files[file_type]['md5sum'] = attrs[0]
                    files[file_type]['size'] = attrs[1]

                    if len(attrs) == 3:
                        files[file_type]['filename'] = attrs[2]
                    elif len(attrs) == 5:
                        files[file_type]['section'] = attrs[2]
                        files[file_type]['priority'] = attrs[3]
                        files[file_type]['filename'] = attrs[4]

        return files


    def parse_relations(self, relations_str):
        relations_list = []

        for relation in relations_str.split(','):
            if re.search('\|', relation):
                alts = relation.split('|')
                alts_list = [self.parse_relation(alt) for alt in alts]
                relations_list.append({'alternative': alts_list})
            else:
                relations_list.append(self.parse_relation(relation))

        return relations_list


    def parse_relation(self, relation_str):
        relation = {}
        relation_re = r'([\w+-.]*)\s*(\(\s*([<>=]{1,2})\s*(.*)\s*\))?\s*(\[(.*)\])?'

        match = re.match(relation_re, relation_str.strip())
        if match:
            if match.group(1):
                relation['name'] = match.group(1)
            if match.group(2):
                relation['relation'] = match.group(3)
                relation['version'] = match.group(4)

            if match.group(6):
                archs = match.group(6).split()
                arch_list = []
                not_arch_list = []

                for arch in archs:
                    if arch[0] == '!':
                        arch_list.append({'name': arch})
                    else:
                        not_arch_list.append({'name': arch})

                if len(arch_list) != 0:
                    relation['arch'] = arch_list
                if len(not_arch_list) != 0:
                    relation['arch'] = not_arch_list

        return {'package': relation}


    def parse_debtags(self, debtags_str):
        debtags = {}

        for tag_str in debtags_str.split(', '):
            tag_splitted = tag_str.strip().split('::', 1)
            if len(tag_splitted) != 2:
                continue
            else:
                (facet, tag) = tag_splitted

            # Replace some characters from tags, otherwise the resulting XML
            # would not be valid.
            tag = tag.replace(':', '-').replace('+', 'p')
            tag = re.sub(r'(^|\W)(\d)', '\g<1>_\g<2>', tag)

            if not debtags.has_key(facet):
                debtags[facet] = []

            # Handle compressed tags, such as "use::{configuring,monitor}".
            c_tags = re.match(r'{(.*)}', tag)
            if c_tags:
                for c_tag in c_tags.group(1).split(','):
                    debtags[facet].append({c_tag: ''})
            else:
                debtags[facet].append({tag: ''})

        return debtags


    def parse_date(self, rfc2822_date_str):
        """Parse a RFC 2822 formatted date string and return its ISO 8601
        representation as string."""
        date_str = rfc2822_date_str[:-6]
        zone_str = rfc2822_date_str[-5:]

        date = time.strptime(date_str, '%a, %d %b %Y %H:%M:%S')
        iso8601_date_str = time.strftime('%Y-%m-%dT%H:%M', date) + zone_str

        return iso8601_date_str


class DebianControl2XMLConverter:

    def create_xml_tree(self, pkg):
        node = Element('package')
        for name, value in pkg.iteritems():
            node.append(self.create_node(name, value))

        return node


    def create_node(self, name, value):
        node = Element(name)

        if type(value) is types.StringType:
            node.text = value

        elif type(value) is types.DictType:
            for new_name in value:
                child = self.create_node(new_name, value[new_name])
                node.append(child)

        elif type(value) is types.ListType:
            for item in value:
                for new_name, new_value in item.iteritems():
                    child = self.create_node(new_name, new_value)
                    node.append(child)

        return node


def main():
    opts = parse_options()
    file_obj = get_file_obj(opts.filename)

    parser = DebianControlParser()
    converter = DebianControl2XMLConverter()

    print '<?xml version="1.0" encoding="UTF-8"?>'
    print '<packages generator="dctrl2xml/' + __version__ + '">'

    data = ''
    for line in file_obj.readlines():
        data += line
        if line.strip() == '':
            if data.strip() != '':
                pkg = parser.parse_package_string(data)
                dump(converter.create_xml_tree(pkg))
            data = ''

    print '</packages>'
    return


def get_file_obj(filename):
    """Return an appropriate file object for filename."""

    if filename == '':
        file_obj = sys.stdin
    else:
        extension = filename.split('.')[-1]
        if extension == 'gz':
            file_obj = gzip.GzipFile
        elif extension == 'bz2':
            file_obj = bz2.BZ2File
        elif zipfile.is_zipfile(filename):
            file_obj = zipfile.ZipFile
        else:
            file_obj = file

        try:
            file_obj = file_obj(filename, 'r')
        except IOError, error:
            sys.stderr.write(error.__str__())
            sys.exit(error.args[0])

    return file_obj


def parse_options():
    parser = optparse.OptionParser(version="%prog " + __version__)
    parser.add_option('-f', '--file',
        dest='filename', default='', metavar='FILE',
        help='read control data from file FILE instead of stdin')

    (opts, args) = parser.parse_args()
    return opts


if __name__ == '__main__':
    main()
