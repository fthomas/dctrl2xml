#!/usr/bin/python2.3
# $Id$
#
# dctrl2xml - a Debian control file to XML converter 
# Copyright (C) 2005 by Frank S. Thomas <frank@thomas-alfeld.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License 
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

import sys
import re
import bz2
import gzip
import optparse
import types
import copy

from xml.dom import minidom, Document, Node
from xml.dom.ext import PrettyPrint

__author__ = 'Frank S. Thomas'
__version__ = '$Revision$'


class DebianControlParser:

    def __init__(self):
        self.contacts = ['maintainer', 'changed-by', 'uploaders']
        self.relations = ['depends', 'pre-depends', 'suggests', 'recommends',
            'conflicts', 'provides', 'replaces', 'enhances', 'build-depends',
            'build-depends-indep', 'build-conflicts']
       

    def ParsePackageString(self, pkg_str):
        self.pkg = {}
        text = {}
        
        for line in pkg_str.split('\n'):
            if not line:
                break
            if line[0] == ' ' and field:
                if text.has_key(field):
                    text[field] += line + '\n'
                else:
                    text[field] = line + '\n'
            else:
                colon = line.find(':')
                field = line[:colon].lower()
                value = line[colon+1:].lstrip()
                
                self.pkg[field] = value

        pkg = copy.copy(self.pkg)
        #self.pkg['name'] = None
        #self.pkg['upstream'] = None
        #self.pkg['long-description'] = None
                
        for field in pkg:
            if field in self.contacts:
                self.pkg[field] = self.ParseContacts(self.pkg[field])
                
            elif field in self.relations:
                self.pkg[field] = self.ParseRelations(self.pkg[field])
                
            elif field == 'package':
                self.pkg['name'] = self.pkg[field]    
                        
            elif field == 'files':
                self.pkg[field] = self.ParseFileList(text[field])
            
            elif field == 'description':
                self.pkg['upstream'] = self.ParseDescription(text[field])     
                self.pkg['long-description'] = text[field]

        #del self.pkg['package']
        #if not self.pkg['upstream']:
        #    del self.pkg['upstream']
        #if not self.pkg['long-description']:
        #    del self.pkg['long-description']
            
        return self.pkg


    def ParseContacts(self, contacts_str):
        contacts_list = []
        
        for contact in contacts_str.split(','):
            match = re.search(r'\s*(.*?)\s*<(.*?)>', contact)
            if match:
                c = {'name': match.group(1), 'email': match.group(2)}
                contacts_list.append({'contact': c})
            else:
                contacts_list.append({'contact': contact})
                
        return contacts_list
        
        
    def ParseFileList(self, files_str):
        files = {}
        files_re = {'dsc': '.*\.dsc',
            'diff': '.*\.diff\.gz',
            'orig': '.*\.orig\.tar\.(gz|bz2)'}
        
        for line in re.finditer(r' ([\da-f]{32}.*)', files_str):
            attrs = line.group(1).split()
            for file_type, file_re in files_re.iteritems():
                if re.search(file_re, attrs[2]):
                    files[file_type] = {}
                    files[file_type]['md5sum'] = attrs[0]
                    files[file_type]['size'] = attrs[1]
                    files[file_type]['filename'] = attrs[2]
                    
        return files


    def ParseDescription(self, desc_str):
        upstream = {}
        upstream_re = r'.*^ (Author|Homepage):\s*(.*)$'
        it = re.compile(upstream_re, re.M+re.S).finditer(desc_str)
              
        for match in it:
            if match.group(1) == 'Author':
                upstream['author'] = self.ParseContacts(match.group(2))
                
            elif match.group(1) == 'Homepage':
                upstream['homepage'] = match.group(2)
                
        return upstream


    def ParseRelations(self, relations_str):
        relations_list = []
        
        for relation in relations_str.split(','):
            if re.search('\|', relation):
                alts = relation.split('|')
                alts_list = [self.ParseRelation(alt) for alt in alts]
                relations_list.append({'alternative': alts_list})
            else:
                relations_list.append(self.ParseRelation(relation))
                
        return relations_list

               
    def ParseRelation(self, relation_str):
        relation = {}
        relation_re = r'([\w+-.]*)\s*(\(\s*([<>=]{2})\s*(.*)\s*\))?\s*(\[(.*)\])?'
        
        match = re.match(relation_re, relation_str.strip())
        if match:
            if match.group(1):
                relation['name'] = match.group(1)       
            if match.group(2):
                relation['relation'] = match.group(3)
                relation['version'] = match.group(4)
                        
            if match.group(6):
                archs = match.group(6).split()
                arch_list = []
                not_arch_list = []
                
                for arch in archs:
                    if arch[0] == '!':
                        arch_list.append({'name': arch})
                    else:
                        not_arch_list.append({'name': arch})
                
                if len(arch_list) != 0:
                    relation['arch'] = arch_list
                if len(not_arch_list) != 0:
                    relation['arch'] = not_arch_list
            
        return {'package': relation}


class DebianControl2XMLConverter:

    def __init__(self, doc):
        self.doc = doc

        
    def CreateXMLTree(self, pkg):
        node = self.doc.createElement('package')   
        for name, value in pkg.iteritems():
            node.appendChild(self.createNode(name, value))
        
        return node
    
        
    def createNode(self, name, value):
        node = self.doc.createElement(name)
        
        if name == 'long-description':
            desc = self.doc.createTextNode(value)
            desc.nodeType = Node.CDATA_SECTION_NODE
            node.appendChild(desc) 
            
        elif type(value) is types.StringType:
            node.appendChild(self.doc.createTextNode(value))
            
        elif type(value) is types.DictType:
            for new_name in value:
                child = self.createNode(new_name, value[new_name])           
                node.appendChild(child)
                
        elif type(value) is types.ListType:
            for item in value:
                for new_name, new_value in item.iteritems():
                    child = self.createNode(new_name, new_value)
                    node.appendChild(child)
                    
        return node
                    

def main():
    opts = parse_options()
    packages = read_packages(opts.filename, opts.encoding)
    
    doc = minidom.parseString('<packages/>')
    root = doc.documentElement
    
    parser = DebianControlParser()
    converter = DebianControl2XMLConverter(doc)

    for package in packages:
        package = package.strip()
        if package != '':
            pkg = parser.ParsePackageString(package)
            pkg_node = converter.CreateXMLTree(pkg)
            root.appendChild(pkg_node)
    
    PrettyPrint(doc)   
    return

     
def read_packages(filename, encoding):
    if filename == '':
        packages = sys.stdin.read()
    else:
        packages = read_packages_from_file(filename)
    
    # Python's minidom expects UTF-8 encoded strings.
    try:
        packages = packages.decode(encoding).encode('utf-8')
    except LookupError, error:
        sys.stderr.write(error)
    
    packages = re.compile('^\n', re.M).split(packages)
    return packages

        
def read_packages_from_file(filename):
    extension = filename.split('.')[-1]
    if extension == 'gz':
        file_obj = gzip.GzipFile
    elif extension == 'bz2':
        file_obj = bz2.BZ2File
    else:
        file_obj = file

    try:
        content = file_obj(filename, 'r').read()
    except IOError, error:
        sys.stderr.write(error)
        sys.exit(error.args[0]);

    return content

        
def parse_options():
    parser = optparse.OptionParser()
    parser.add_option('-f', '--file', dest='filename',
                      default='', metavar='FILE')
    parser.add_option('-e', '--encoding', dest='encoding',
                      default='utf-8', metavar='ENC')
    
    (opts, args) = parser.parse_args()
    return opts

        
if __name__ == '__main__':
    main()
