#!/usr/bin/python2.3
# $Id$
#
# dctrl2xml - a Debian control file to XML converter 
# Copyright (C) 2005 by Frank S. Thomas <frank@thomas-alfeld.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License 
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

import sys
import re
import bz2
import gzip

from optparse import OptionParser
from types import *
from xml.dom import minidom, Document, Node
from xml.dom.ext import PrettyPrint

__author__ = 'Frank S. Thomas'
__version__ = '$Revision$'
__date__ = '$Date$'


class DCtrlParser:

    def __init__(self, text):
        self.text = text
        self.persons = ['Maintainer', 'Changed-By']
        self.relations = ['Depends', 'Pre-Depends', 'Suggests', 'Recommends',
                          'Conflicts', 'Provides', 'Replaces', 'Enhances',
                          'Build-Depends', 'Build-Depends-Indep',
                          'Build-Conflicts']
        self.pkg = {}
        self._pkg_parse()
        
    def _pkg_parse(self):
        fields_re = r'^([\w-]*): ?(.*)\n( (.|\n)*)?'
        it = re.compile(fields_re, re.M).finditer(self.text)
        for match in it:
            field_name = match.group(1)
            field_value = match.group(2)
            field_text = match.group(3)
            if field_name in self.persons:
                self.pkg[field_name] = self._pkg_parse_person(field_value)
            elif field_name == 'Files':
                self.pkg[field_name] = self._pkg_parse_files(field_text)
            elif field_name == 'Description':
                self.pkg[field_name] = field_value
                self._pkg_parse_description(field_text)
            elif field_name in self.relations:
                self.pkg[field_name] = self._pkg_parse_relations(field_value)
            elif field_name == 'Package':
                self.pkg['Name'] = field_value
            else:
                self.pkg[field_name] = field_value     
              
    def _pkg_parse_person(self, person):
        match = re.compile(r'(.*) <(.*)>').search(person)
        if match:
            return {'Name': match.group(1), 'Email': match.group(2)}
            
    def _pkg_parse_files(self, files_text):
        files = {}
        files_re = {'DSC': '.*\.dsc',
                    'Diff': '.*\.diff\.gz',
                    'Orig': '.*\.orig\.tar\.gz'}
        it = re.compile(r' ([0-9a-f]{32}.*)').finditer(files_text)
        for line in it:
            if line.group(1):
                attrs = line.group(1).split(' ')
                for file_type, file_re in files_re.iteritems():                
                    if re.search(file_re, attrs[2]):
                        files[file_type] = {}
                        files[file_type]['MD5sum'] = attrs[0]
                        files[file_type]['Size'] = attrs[1]
                        files[file_type]['Filename'] = attrs[2]
        return files
    
    def _pkg_parse_description(self, desc_text):
        hp_re = r'(.|\n)*^ Homepage: (.*)$'
        hp_match = re.compile(hp_re, re.M).match(desc_text)
        if hp_match:
            self.pkg['Homepage'] = hp_match.group(2)
        self.pkg['Long-Description'] = \
            desc_text.replace('\n ', '\n').strip()
    
    def _pkg_parse_relations(self, relations_text):
        relations = relations_text.split(',')
        relations_list = []
        for relation in relations:
            if re.search('\|', relation):
                alts = relation.split('|')
                alts_list = []
                for alt in alts:
                    alts_list.append(self._pkg_parse_relation(alt))
                relations_list.append({'Alternative': alts_list})
            else:
                relations_list.append(self._pkg_parse_relation(relation))
        return relations_list
        
    def _pkg_parse_relation(self, relation_text):
        relation_text = relation_text.strip()
        relation_re = r'([\w\+\-\.]*) ?(\(([<>=]{2}) (.*)\))? ?(\[(.*)\])?'
        relation = {}
    
        match = re.match(relation_re, relation_text)
        if match:
            if match.group(1):
                relation['Name'] = match.group(1)
            if match.group(2):
                relation['Relation'] = match.group(3)
                relation['Version'] = match.group(4)
            if match.group(5):
                archs = match.group(6).split(' ')
                arch_list = []
                narch_list = []
                for arch in archs:
                    if arch[0] == '!':
                        narch_list.append(arch[1:])
                    else:
                        arch_list.append(arch)
                relation['NotArch'] = narch_list
                relation['Arch'] = arch_list
            
        return {'Package': relation}
    
    def pkgToXML(self, doc):
        node = doc.createElement('package')        
        for name, value in self.pkg.iteritems():
            node.appendChild(self._pkg_create_node(doc, name, value))
        return node

    def _pkg_create_node(self, doc, name, value):
        node = doc.createElement(name.lower())
        if name == 'Long-Description':
             desc = doc.createTextNode(value)
             desc.nodeType = Node.CDATA_SECTION_NODE
             node.appendChild(desc)
        elif type(value) is StringType:
            node.appendChild(doc.createTextNode(value))
        elif type(value) is DictType:
            for new_name in value:
                node.appendChild(self._pkg_create_node(doc, new_name,
                                                       value[new_name]))
        elif type(value) is ListType:
            for item in value:
                for new_name, new_value in item.iteritems():
                    node.appendChild(self._pkg_create_node(doc, new_name,
                                                           new_value))
        return node
            

def main():
    opts = parse_options()
    packages = read_packages(opts.filename)

    doc = minidom.parseString('<packages/>')
    root = doc.documentElement
    
    for package in packages:
        package = package.strip()
        if package != '':
            dcparser = DCtrlParser(package)
            root.appendChild(dcparser.pkgToXML(doc))
            
    PrettyPrint(doc)
    return

     
def read_packages(filename):
    if not filename:
        packages = sys.stdin.read()
    else:
        packages = read_packages_from_file(filename)
    packages = re.compile('^\n', re.M).split(packages)
    return packages

        
def read_packages_from_file(filename):
    extension = filename.split('.')[-1]
    if extension == 'gz':
        file_obj = gzip.GzipFile
    elif extension == 'bz2':
        file_obj = bz2.BZ2File
    else:
        file_obj = file

    try:
        content = file_obj(filename, 'r').read()
    except IOError, error:
        print error
        sys.exit(error.args[0]);
        
    return content

        
def parse_options():
    parser = OptionParser()
    parser.add_option('-f', '--file', dest='filename',
                      default='', metavar='FILE')
    (opts, args) = parser.parse_args()
    return opts

        
if __name__ == '__main__':
    main()
