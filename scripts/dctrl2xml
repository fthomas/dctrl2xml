#!/usr/bin/python2.3
# $Id: dctrl2xml 342 2005-01-10 21:56:23Z mrfrost $
#
# dctrl2xml - a Debian control file to XML converter 
# Copyright (C) 2005 by Frank S. Thomas <frank@thomas-alfeld.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License 
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

import sys
import re
import bz2
import gzip

from optparse import OptionParser
from types import *
from xml.dom import minidom, Document, Node
from xml.dom.ext import PrettyPrint

__author__ = 'Frank S. Thomas'
__version__ = '$Revision: 344 $'
__date__ = '$Date$'


"""        
        for field in parsed_pkg.iterkeys():
        # parse package relationships
        if field in relation:
            parsed_pkg[field] = parse_package_relations(parsed_pkg[field])
     


        
def parse_package_relations(relations_text):
    relations = relations_text.split(',')
    relations_list = []
    
    for relation in relations:
        if re.search('\|', relation):
            alternatives = relation.split('|')
            alternatives_list = []
            for alternative in alternatives:
                alternatives_list.append(parse_relation(alternative))
            relations_list.append({'Alternative': alternatives_list})
        else:
            relations_list.append(parse_relation(relation))
    
    return relations_list

                
def parse_relation(relation):
    relation = relation.strip()
    relation_re = r'([\w\+\-\.]*) ?(\(([<>=]{2}) (.*)\))? ?(\[(.*)\])?'
    relation_pkg = {}
    
    match = re.match(relation_re, relation)
    if match:
        if match.group(1):
            relation_pkg['Package'] = match.group(1)
        if match.group(2):
            relation_pkg['Relation'] = match.group(3)
            relation_pkg['Version'] = match.group(4)
        if match.group(5):
            arches = match.group(6).split(' ')
            arch_list = []
            narch_list = []
            for arch in arches:
                if arch[0] == '!':
                    narch_list.append(arch[1:])
                else:
                    arch_list.append(arch)
            relation_pkg['!Arch'] = narch_list
            relation_pkg['Arch'] = arch_list
            
    return relation_pkg    

def make_node(doc, name, content):
    node = doc.createElement(name.lower())

    # package has package!!!!!!!!!!!!!!!!    
    if type(content) is StringType:
        node.appendChild(doc.createTextNode(content))
    elif type(content) is DictType:
        for field in content:
            node.appendChild(make_node(doc, field, content[field]))
#    elif type(content) is ListType:
#        if name == 'Long-Description':
#            for para in content:
                #p = 
                #node.appendChild(doc.createTextNode(para))
        
    return node

"""

class DCtrlParser:

    def __init__(self, text):
        self.text = text
        self.persons = ['Maintainer', 'Changed-By']
        self.relations = ['Depends', 'Pre-Depends', 'Suggests', 'Recommends',
                          'Conflicts', 'Provides', 'Replaces', 'Enhances',
                          'Build-Depends', 'Build-Depends-Indep',
                          'Build-Conflicts']
        self.pkg = {}
        self._pkg_parse()
        
    def _pkg_parse(self):
        fields_re = r'^([\w-]*): ?(.*)\n( (.|\n)*)?'
        it = re.compile(fields_re, re.M).finditer(self.text)
        for match in it:
            field_name = match.group(1)
            field_value = match.group(2)
            field_text = match.group(3)
            if field_name in self.persons:
                self.pkg[field_name] = self._pkg_parse_person(field_value)
            elif field_name == 'Files':
                self.pkg[field_name] = self._pkg_parse_files(field_text)
            elif field_name == 'Description':
                self.pkg[field_name] = field_value
                self._pkg_parse_description(field_text)
        
        print self.pkg        
              
    def _pkg_parse_person(self, person):
        match = re.compile(r'(.*) <(.*)>').search(person)
        if match:
            return {'Name': match.group(1), 'Email': match.group(2)}
            
    def _pkg_parse_files(self, files_text):
        files = {}
        files_re = {'DSC': '.*\.dsc',
                    'Diff': '.*\.diff\.gz',
                    'Orig': '.*\.orig\.tar\.gz'}
        it = re.compile(r' ([0-9a-f]{32}.*)').finditer(files_text)
        for line in it:
            if line.group(1):
                attrs = line.group(1).split(' ')
                for file_type, file_re in files_re.iteritems():                
                    if re.search(file_re, attrs[2]):
                        files[file_type] = {}
                        files[file_type]['MD5sum'] = attrs[0]
                        files[file_type]['Size'] = attrs[1]
                        files[file_type]['Filename'] = attrs[2]
        return files
    
    def _pkg_parse_description(self, desc_text):

        hp_re = r'(.|\n)*^ Homepage: (.*)$'
        hp_match = re.compile(hp_re, re.M).match(desc_text)
        if hp_match:
            self.pkg['Homepage'] = hp_match.group(2)
    
    def pkgToXML(self, doc):
        node = doc.createElement('package')
        return node

    
def main():
    opts = parse_options()
    packages = read_packages(opts.filename)

    doc = minidom.parseString('<packages/>')
    root = doc.documentElement
    
    for package in packages:
        package = package.strip()
        if package != '':
            dcparser = DCtrlParser(package)
            root.appendChild(dcparser.pkgToXML(doc))
            
    PrettyPrint(doc)
    return

     
def read_packages(filename):
    if not filename:
        packages = sys.stdin.read()
    else:
        packages = read_packages_from_file(filename)
    packages = re.compile('^\n', re.M).split(packages)
    return packages

        
def read_packages_from_file(filename):
    extension = filename.split('.')[-1]
    if extension == 'gz':
        file_obj = gzip.GzipFile
    elif extension == 'bz2':
        file_obj = bz2.BZ2File
    else:
        file_obj = file

    try:
        content = file_obj(filename, 'r').read()
    except IOError, error:
        print error
        sys.exit(error.args[0]);
        
    return content

        
def parse_options():
    parser = OptionParser()
    parser.add_option('-f', '--file', dest='filename',
                      default='', metavar='FILE')
    (opts, args) = parser.parse_args()
    return opts

        
if __name__ == '__main__':
    main()
