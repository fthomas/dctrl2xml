#!/usr/bin/python2.3
# $Id$
#
# dctrl2xml - a Debian control file to XML converter 
# Copyright (C) 2005 by Frank S. Thomas <frank@thomas-alfeld.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License 
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

import sys
import re
import bz2
import gzip
import optparse

__author__ = 'Frank S. Thomas'
__version__ = '$Revision$'


class DebianControlParser:

    def __init__(self, pkg_str=''):
        self.contacts = ['maintainer', 'changed-by', 'uploaders']
        self.relations = ['depends', 'pre-depends', 'suggests', 'recommends',
            'conflicts', 'provides', 'replaces', 'enhances', 'build-depends',
            'build-depends-indep', 'build-conflicts']
        
        if pkg_str != '':
            self._pkg_parse(pkg_str)
    
    #def ParsePackageString(self, pkg_str):
    #    return
        
        
    def ParseContacts(self, contacts_str):
        contacts_list = []
        
        for contact in contacts_str.split(','):
            match = re.search(r'\s*(.*?)\s*<(.*?)>', contact)
            if match:
                c = {'name': match.group(1), 'email': match.group(2)}
                contacts_list.append({'contact': c})
            else:
                contacts_list.append({'contact': contact})
                
        return contacts_list
        
        
    #def ParseFileList(self, files_str):
    #    return
        
        
    def ParseDescription(self, desc_str):
        upstream_re = r'.*^ (Author|Homepage):\s*(.*)$'
        it = re.compile(upstream_re, re.M+re.S).finditer(desc_str)
        
        for match in it:
            if match.group(1) == 'Author':
                self.pkg['author'] = self.ParseContacts(match.group(2))
            elif match.group(1) == 'Homepage'
                self.pkg['homepage'] = match.group(2)
        
        self.pkg['long-description'] = desc_str
        
        
    def ParseRelations(self, relations_str):
        relations_list = []
        
        for relation in relations_str.split(','):
            if re.search('\|', relation):
                alts = relation.split('|')
                alts_list = [self.ParseRelation(alt) for alt in alts]
                relations_list.append({'alternative': alts_list})
            else:
                relations_list.append(self.ParseRelation(relation))
                
        return relations_list

               
    def ParseRelation(self, relation_str):
        relation = {}
        relation_re = r'([\w+-.]*)\s*(\(\s*([<>=]{2})\s*(.*)\s*\))?\s*(\[(.*)\])?'
        
        match = re.match(relation_re, relation_str.strip())
        if match:
            if match.group(1):
                relation['name'] = match.group(1)
            if match.group(2):
                relation['relation'] = match.group(3)
                relation['version'] = match.group(4)
            if match.group(6):
                archs = match.group(6).split()
                arch_list = filter(lambda arch: arch[0] != '!', archs)
                not_arch_list = filter(lambda arch: arch[0] == '!', archs)
                
                if len(arch_list) != 0:
                    relation['arch'] = arch_list
                if len(not_arch_list) != 0:
                    relation['arch'] = not_arch_list
            
        return {'package': relation}


def main():
    opts = parse_options()
    packages = read_packages(opts.filename, opts.encoding)
        
    for package in packages:
        package = package.strip()
        if package != '':  
            parser = DebianControlParser(package)
            
    return

     
def read_packages(filename, encoding):
    if filename == '':
        packages = sys.stdin.read()
    else:
        packages = read_packages_from_file(filename)
    
    # Python's minidom expects UTF-8 encoded strings.
    try:
        packages = packages.decode(encoding).encode('utf-8')
    except LookupError, error:
        sys.stderr.write(error)
    
    packages = re.compile('^\n', re.M).split(packages)
    return packages

        
def read_packages_from_file(filename):
    extension = filename.split('.')[-1]
    if extension == 'gz':
        file_obj = gzip.GzipFile
    elif extension == 'bz2':
        file_obj = bz2.BZ2File
    else:
        file_obj = file

    try:
        content = file_obj(filename, 'r').read()
    except IOError, error:
        sys.stderr.write(error)
        sys.exit(error.args[0]);

    return content

        
def parse_options():
    parser = optparse.OptionParser()
    parser.add_option('-f', '--file', dest='filename',
                      default='', metavar='FILE')
    parser.add_option('-e', '--encoding', dest='encoding',
                      default='utf-8', metavar='ENC')
    
    (opts, args) = parser.parse_args()
    return opts

        
if __name__ == '__main__':
    main()
